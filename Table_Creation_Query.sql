create table ban_list (ban_expired date, is_permanent boolean not null, user_id uuid not null, primary key (user_id));
create table complaints (id uuid not null, recipe_id uuid, user_id uuid, user_sender_id uuid not null, description varchar(255), status varchar(255) check (status in ('Pending','Active','Solved','Dismissed')), topic varchar(255), primary key (id));
create table email_confirmations (confirmed boolean, deleted boolean, token_expired date, id uuid not null, email varchar(255), hash varchar(255), salt varchar(255), primary key (id), unique (email));
create table filters (deleted boolean, id uuid not null, name jsonb, primary key (id));
create table ingredients (amount float(53), deleted boolean, id uuid not null, recipe_id uuid not null, measure_type varchar(255) check (measure_type in ('Gram','KiloGram','Litre','Millilitres','Amount','TableSpoon','TeaSpoon')), name jsonb, primary key (id));
create table recipes (deleted boolean, rating float(53), id uuid not null, user_id uuid not null, recipe_description varchar(255), recipe_name varchar(255), primary key (id));
create table recipes_filters (filter_id uuid not null, recipe_id uuid not null);
create table reviews (deleted boolean, rating integer, id uuid not null, recipe_id uuid not null, user_id uuid not null, text varchar(255), primary key (id));
create table reviews_stats (absolute_average_rating float(53), confidence_reviews_count float(53), id bigint generated by default as identity, primary key (id));
create table steps (deleted boolean, duration_minutes float4, step_order integer, id uuid not null, recipe_id uuid not null, description varchar(255), primary key (id));
create table user_role (user_id uuid not null, roles varchar(255) check (roles in ('USER','ADMIN','EDITOR')));
create table users (deleted boolean, email_conf_id uuid unique, id uuid not null, about_me varchar(255), login varchar(255), nickname varchar(255), password varchar(255), primary key (id));
alter table if exists ban_list add constraint FKsf7oxvkhnu7voeiopc042m8v6 foreign key (user_id) references users;
alter table if exists complaints add constraint FK7snxxi19gd9e4gfhtdviox8j1 foreign key (recipe_id) references recipes;
alter table if exists complaints add constraint FK83j5gqkd7ku4vc908g4rtmglr foreign key (user_id) references users;
alter table if exists complaints add constraint FKjlaxrk4mv5n2ps5f5a3aqpv01 foreign key (user_sender_id) references users;
alter table if exists ingredients add constraint FK7p08vcn6wf7fd6qp79yy2jrwg foreign key (recipe_id) references recipes;
alter table if exists recipes add constraint FKlc3x6yty3xsupx80hqbj9ayos foreign key (user_id) references users;
alter table if exists recipes_filters add constraint FKm2dsal6i04rod8orql9dw62cu foreign key (filter_id) references filters;
alter table if exists recipes_filters add constraint FKjsfhkulj43jlk6s7m6xdv1uvm foreign key (recipe_id) references recipes;
alter table if exists reviews add constraint FKdubqj24wyqsxwg1vsut9uoce1 foreign key (recipe_id) references recipes;
alter table if exists reviews add constraint FKcgy7qjc1r99dp117y9en6lxye foreign key (user_id) references users;
alter table if exists steps add constraint FK729dw6qpupm85tlbq57rqbpru foreign key (recipe_id) references recipes;
alter table if exists user_role add constraint FKj345gk1bovqvfame88rcx7yyx foreign key (user_id) references users;
alter table if exists users add constraint FK71vrgf258sd2oh0cd40see2nf foreign key (email_conf_id) references email_confirmations;


insert into reviews_stats(absolute_average_rating, confidence_reviews_count) values
(0.0, 0.0);

CREATE OR REPLACE VIEW recipes_reviews_stats_view AS
SELECT rec."id" AS "recipe_id", COUNT(r.id) AS "reviews_count", AVG(r.rating) AS "average_rating", COUNT(c.id) as "complaints_count"
FROM recipes as rec
LEFT JOIN reviews as r ON rec."id" = r.recipe_id
LEFT JOIN complaints as c ON rec."id" = c.recipe_id AND c.status in ('Active', 'Solved')
GROUP BY rec."id";





CREATE OR REPLACE FUNCTION get_recipe_rating(recipeID UUID)
RETURNS REAL
LANGUAGE plpgsql
AS 
$$
DECLARE recipePopularityStats RECORD;
	popularityStats RECORD;
	activeComplaintsCount INTEGER;
	solvedComplaintsCount INTEGER;
BEGIN
	SELECT * INTO recipePopularityStats FROM recipes_reviews_stats_view
	WHERE recipe_id = recipeID
	LIMIT 1;

	SELECT * INTO popularityStats FROM reviews_stats
	LIMIT 1;

	SELECT COUNT(*) INTO activeComplaintsCount
	FROM complaints
	WHERE status = 'Active';
	
	SELECT COUNT(*) INTO solvedComplaintsCount
	FROM complaints
	WHERE status = 'Solved';
	
	RETURN (recipePopularityStats.average_rating * recipePopularityStats.reviews_count + popularityStats.confidence_reviews_count * popularityStats.absolute_average_rating)/ (recipePopularityStats.reviews_count + popularityStats.confidence_reviews_count);
END;
$$;



CREATE OR REPLACE FUNCTION reviews_table_changes_func()
	RETURNS TRIGGER 
	LANGUAGE plpgsql
	AS 
$$
DECLARE conf_records_count INTEGER;
	abs_avg REAL;
	conf_rev_count REAL;
	stats RECORD;
BEGIN
	SELECT CEIL(COUNT(*)/3.0)
	INTO conf_records_count
	FROM reviews;

	SELECT ROUND(AVG(rating), 2)
	INTO abs_avg
	FROM reviews;

	SELECT ROUND(AVG("rev_count"), 2)
	INTO conf_rev_count
	FROM (SELECT recipe_id, COUNT("id") as "rev_count"
		FROM reviews
		GROUP BY recipe_id
		ORDER BY "rev_count");

	SELECT *
	INTO stats
	FROM reviews_stats
	LIMIT 1;

	IF(stats.absolute_average_rating <> abs_avg OR stats.confidence_reviews_count <> conf_rev_count) THEN
		UPDATE reviews_stats
		SET absolute_average_rating = abs_avg,
		confidence_reviews_count = conf_rev_count;
	END IF;
	RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER reviews_table_insert_trg
AFTER INSERT
on reviews
for each row 
execute procedure reviews_table_changes_func();

CREATE OR REPLACE TRIGGER reviews_table_delete_trg
AFTER DELETE
on reviews
for each row 
execute procedure reviews_table_changes_func();

CREATE OR REPLACE TRIGGER reviews_table_update_trg
AFTER UPDATE OF rating
on reviews
for each row 
execute procedure reviews_table_changes_func();



CREATE OR REPLACE FUNCTION reviews_stats_changes_func()
	RETURNS TRIGGER 
	LANGUAGE plpgsql
	AS 
$$
BEGIN
	UPDATE recipes
	SET rating = get_recipe_rating(id);
	RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER reviews_stats_changes_trg
AFTER UPDATE on reviews_stats
for each row 
execute procedure reviews_stats_changes_func();


-- Triggers
CREATE OR REPLACE FUNCTION steps_order_delete_func()
	RETURNS TRIGGER 
	LANGUAGE plpgsql
	AS 
$$
DECLARE maxOrder INTEGER;
BEGIN
	UPDATE steps
	SET step_order = step_order - 1
	WHERE recipe_id = OLD.recipe_id AND step_order > OLD.step_order;

	RETURN OLD;
END;
$$;
CREATE OR REPLACE TRIGGER steps_order_delete_trg
AFTER DELETE on steps
for each row 
execute procedure steps_order_delete_func();


CREATE OR REPLACE FUNCTION steps_order_insert_func()
	RETURNS TRIGGER 
	LANGUAGE plpgsql
	AS 
$$
DECLARE maxOrder INTEGER;
BEGIN
	SELECT MAX(step_order) INTO maxOrder
	FROM steps
	WHERE recipe_id = NEW.recipe_id;

	NEW.step_order = maxOrder+1;
	RETURN NEW;
END;
$$;
CREATE OR REPLACE TRIGGER steps_order_insert_trg
BEFORE INSERT on steps
for each row 
execute procedure steps_order_insert_func();



CREATE OR REPLACE FUNCTION steps_order_update_trg()
	RETURNS TRIGGER 
	LANGUAGE plpgsql
	AS
$$
DECLARE maxOrder INTEGER;
BEGIN
	SELECT MAX(step_order) INTO maxOrder
	FROM steps WHERE recipe_id = NEW.recipe_id;
	
	IF(NEW.step_order - maxOrder > 1) THEN
		NEW.step_order = maxOrder + 1;
	END IF;

	IF(ABS(NEW.step_order - OLD.step_order) > 1) THEN
		IF(NEW.step_order > OLD.step_order) THEN
			UPDATE steps
			SET step_order = step_order - 1
			WHERE recipe_id = NEW.recipe_id AND step_order <= NEW.step_order AND step_order > OLD.step_order;
		ELSIF (NEW.step_order < OLD.step_order) then
			UPDATE steps
			SET step_order = step_order + 1
			WHERE recipe_id = NEW.recipe_id AND step_order >= NEW.step_order AND step_order < OLD.step_order;
		END IF;
	END IF;

	RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER steps_order_insert_trg
BEFORE UPDATE of step_order
on steps
for each row 
execute procedure steps_order_update_trg();